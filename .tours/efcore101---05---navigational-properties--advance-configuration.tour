{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "EFCore101 - 05 - Navigational properties & advance configuration",
  "steps": [
    {
      "file": "EFCore101.API/entities/Book.cs",
      "description": "## One-to-Many Relationship: Book to Author\r\n\r\nThe code shows how a Book is related to an Author in a one-to-many relationship. This means one author can write multiple books, but each book has only one author.\r\n\r\n### Key Components:\r\n\r\n1. **Foreign Key Property**:\r\n   ```csharp\r\n   public Guid? AuthorId { get; set; }\r\n   ```\r\n   This property stores the ID of the author who wrote the book. The `?` makes it nullable, meaning a book can exist without an assigned author.\r\n\r\n2. **Navigation Property**:\r\n   ```csharp\r\n   public virtual Author? Author { get; set; }\r\n   ```\r\n   This creates a reference to the actual Author object. The `virtual` keyword enables lazy loading, meaning the author data is only loaded when accessed. The `?` indicates this relationship is optional.\r\n\r\n3. **Relationship Configuration** (from BookConfiguration.cs):\r\n   ```csharp\r\n   builder.HasOne(b => b.Author)\r\n       .WithMany(a => a.Books)\r\n       .HasForeignKey(b => b.AuthorId)\r\n       .IsRequired(false)\r\n       .OnDelete(DeleteBehavior.SetNull);\r\n   ```\r\n   This Fluent API configuration:\r\n   - Establishes that each book has one author (`HasOne`)\r\n   - Specifies that each author can have many books (`WithMany`)\r\n   - Identifies the foreign key property (`HasForeignKey`)\r\n   - Makes the relationship optional (`IsRequired(false)`)\r\n   - Sets what happens when an author is deleted - the AuthorId in related books becomes null (`OnDelete(DeleteBehavior.SetNull)`)\r\n\r\n### Why This Approach?\r\n\r\n- **Flexibility**: Books can exist without authors (useful for drafts or anonymous works)\r\n- **Data Integrity**: When an author is deleted, books aren't deleted but become authorless\r\n- **Efficient Queries**: You can easily find all books by a specific author using the relationship\r\n- **Bidirectional Navigation**: You can navigate from books to authors and from authors to their books",
      "line": 34
    },
    {
      "file": "EFCore101.API/entities/Book.cs",
      "description": "## One-to-One Relationship: Book and BookDetails\r\n\r\nThe code snippet shows a one-to-one relationship between Book and BookDetails. In this relationship, each book has exactly one set of details, and each set of details belongs to exactly one book.\r\n\r\n### Why There's No BookDetailId in Book Class\r\n\r\nIn this implementation, we're using a **principal-dependent** pattern where:\r\n\r\n1. **Book** is the principal entity (the \"owner\" of the relationship)\r\n2. **BookDetails** is the dependent entity (it depends on Book to exist)\r\n\r\nThe foreign key is placed on the dependent side (BookDetails) rather than the principal side (Book). This is why:\r\n\r\n```csharp\r\n// In BookDetails.cs\r\npublic Guid BookId { get; set; }\r\n```\r\n\r\nBut in Book.cs, there's only a navigation property:\r\n\r\n```csharp\r\npublic virtual BookDetails? Details { get; set; }\r\n```\r\n\r\n### Key Points:\r\n\r\n1. **Inverse Relationship**: The foreign key is on the dependent side (BookDetails), not the principal side (Book).\r\n\r\n2. **Configuration**: The relationship is configured in BookDetailsConfiguration.cs:\r\n   ```csharp\r\n   builder.HasOne(d => d.Book)\r\n       .WithOne(b => b.Details)\r\n       .HasForeignKey<BookDetails>(d => d.BookId)\r\n       .OnDelete(DeleteBehavior.Cascade);\r\n   ```\r\n\r\n3. **Primary Key as Foreign Key**: In BookDetailsConfiguration, we actually make BookId both the primary key and foreign key:\r\n   ```csharp\r\n   builder.HasKey(d => d.BookId);\r\n   ```\r\n   This enforces that:\r\n   - Each BookDetails must have a Book\r\n   - Each Book can have at most one BookDetails\r\n   - BookDetails cannot exist without a Book\r\n\r\n4. **Advantages**:\r\n   - Simpler model (no need for two IDs)\r\n   - Enforces relationship at database level\r\n   - More efficient queries (no need for joins on separate IDs)\r\n   - Guarantees data integrity\r\n\r\nThis is a common pattern for one-to-one relationships in EF Core when one entity (BookDetails) conceptually \"belongs to\" the other entity (Book).",
      "line": 54
    },
    {
      "file": "EFCore101.API/entities/Book.cs",
      "description": "## Many-to-Many Relationship: Book and Category\r\n\r\nThe code shows how books and categories are related in a many-to-many relationship. This means:\r\n- A book can belong to multiple categories (e.g., a book can be both \"Science Fiction\" and \"Adventure\")\r\n- A category can contain multiple books (e.g., the \"Mystery\" category includes many different books)\r\n\r\n### Key Components:\r\n\r\n1. **Collection Navigation Property in Book**:\r\n   ```csharp\r\n   public virtual ICollection<Category> Categories { get; set; } = new List<Category>();\r\n   ```\r\n   This property represents all categories that a book belongs to. The `ICollection<Category>` type indicates that a book can have multiple categories.\r\n\r\n2. **Matching Collection in Category**:\r\n   ```csharp\r\n   public virtual ICollection<Book> Books { get; set; } = new List<Book>();\r\n   ```\r\n   This property represents all books in a particular category.\r\n\r\n3. **Join Table Configuration** (from CategoryConfiguration.cs):\r\n   ```csharp\r\n   builder.HasMany(c => c.Books)\r\n       .WithMany(b => b.Categories)\r\n       .UsingEntity(\r\n           \"BookCategory\",\r\n           l => l.HasOne(typeof(Book)).WithMany().HasForeignKey(\"BookId\"),\r\n           r => r.HasOne(typeof(Category)).WithMany().HasForeignKey(\"CategoryId\"),\r\n           j => {\r\n               j.HasKey(\"BookId\", \"CategoryId\");\r\n               j.ToTable(\"BookCategory\");\r\n           });\r\n   ```\r\n\r\n### Why No Direct Foreign Keys?\r\n\r\nUnlike one-to-many relationships, many-to-many relationships don't have foreign key properties directly in either entity. Instead:\r\n\r\n1. **Join Table**: EF Core creates a hidden join table (named \"BookCategory\" in this case) that contains:\r\n   - A foreign key to Book (BookId)\r\n   - A foreign key to Category (CategoryId)\r\n   - A composite primary key of both columns\r\n\r\n2. **No Skip Navigation**: This example uses traditional collection navigation properties rather than skip navigations (a newer EF Core feature).\r\n\r\n### Benefits of This Approach:\r\n\r\n1. **Natural Modeling**: Represents the real-world relationship accurately\r\n2. **Flexibility**: Books can be in any number of categories\r\n3. **Bidirectional Navigation**: You can navigate from books to their categories and from categories to their books\r\n4. **Clean Domain Model**: No need for complex join entities in your domain model\r\n\r\n### Usage Examples:\r\n\r\n- To add a book to a category:\r\n  ```csharp\r\n  book.Categories.Add(category);\r\n  // or\r\n  category.Books.Add(book);\r\n  ```\r\n\r\n- To find all books in a category:\r\n  ```csharp\r\n  var booksInCategory = category.Books;\r\n  ```\r\n\r\n- To find all categories of a book:\r\n  ```csharp\r\n  var categoriesOfBook = book.Categories;\r\n  ```",
      "line": 59
    },
    {
      "file": "EFCore101.API/Configurations/CategoryConfiguration.cs",
      "description": "## Shadow Properties in EF Core\r\n\r\nShadow properties are properties that exist in the database but are not defined in your entity classes\r\n### 1. The BookCategory Join Table\r\n\r\n```csharp\r\nbuilder.HasMany(b => b.Categories)\r\n    .WithMany(c => c.Books)\r\n    .UsingEntity(\r\n        \"BookCategory\",\r\n        l => l.HasOne(typeof(Category)).WithMany().HasForeignKey(\"CategoryId\"),\r\n        r => l.HasOne(typeof(Book)).WithMany().HasForeignKey(\"BookId\"),\r\n        j => j.HasKey(\"BookId\", \"CategoryId\"));\r\n```\r\n\r\nThis creates a complete table with `BookId` and `CategoryId` columns, but there is no corresponding C# class for this table. The properties `BookId` and `CategoryId` in the join table are shadow properties because they exist only in the database model, not in your C# code.\r\n",
      "line": 34
    }
  ]
}