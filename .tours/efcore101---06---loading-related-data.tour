{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "EFCore101 - 06 - Loading related data",
  "steps": [
    {
      "file": "EFCore101.API/Endpoints/LoadingExamplesEndpoints.cs",
      "description": "# Eager Loading\r\n\r\n```csharp\r\nvar booksWithAuthorsAndPublishers = await context.Books\r\n    .AsNoTracking()\r\n    .Include(b => b.Author)\r\n    .Include(b => b.Publisher)\r\n    .Include(b => b.Details)\r\n    .Include(b => b.Categories)\r\n    .ToListAsync(cancellationToken);\r\n```\r\n\r\n**What's happening:**\r\n- We load books AND all their related data (authors, publishers, details, categories) in a **single database query**\r\n- The `.Include()` method tells EF Core which related entities to bring along\r\n- `.AsNoTracking()` improves performance when we only need to read data, not modify it\r\n\r\n**When to use it:**\r\n- When you know you'll need the related data\r\n- When you want to avoid multiple database trips\r\n- For displaying complete information about entities and their relationships\r\n\r\n**Pros:** One database trip, prevents the \"N+1 query problem\" (where you make 1 query for main data + N queries for each related item)\r\n**Cons:** May retrieve more data than you actually need",
      "line": 15
    },
    {
      "file": "EFCore101.API/Endpoints/LoadingExamplesEndpoints.cs",
      "description": "# Lazy Loading\r\n\r\n```csharp\r\nvar books = await context.Books.ToListAsync(cancellationToken);\r\n\r\nvar result = books.Select(book => new\r\n{\r\n    BookId = book.Id,\r\n    Title = book.Title,\r\n    // These will trigger separate database queries when accessed\r\n    AuthorName = book.Author?.Name,\r\n    PublisherName = book.Publisher?.Name,\r\n    CategoryCount = book.Categories.Count,\r\n    PageCount = book.Details?.NumberOfPages\r\n}).ToList();\r\n```\r\n\r\n**What's happening:**\r\n- We first load just the books (without related data)\r\n- When we access navigation properties like `book.Author` or `book.Categories`, EF Core automatically makes additional database queries to load that data\r\n- This requires:\r\n  1. Virtual navigation properties (`public virtual Author? Author { get; set; }`)\r\n  2. The Microsoft.EntityFrameworkCore.Proxies package\r\n  3. Enabling lazy loading in your DbContext configuration\r\n\r\n**When to use it:**\r\n- When you're not sure which related data you'll need\r\n- For simple applications where performance isn't critical\r\n- When working with a small number of entities\r\n\r\n**Pros:** Simple to use, loads only what you actually access\r\n**Cons:** Can cause performance problems (the N+1 query problem) when working with many entities",
      "line": 36
    },
    {
      "file": "EFCore101.API/Endpoints/LoadingExamplesEndpoints.cs",
      "description": "# Explicit Loading\r\n\r\n```csharp\r\nvar book = await dbContext.Books\r\n    .SingleOrDefaultAsync(b => b.Id == bookId, cancellationToken);\r\n    \r\n// Then explicitly load related data as needed\r\nawait dbContext.Entry(book)\r\n    .Reference(b => b.Author)\r\n    .LoadAsync(cancellationToken);\r\n    \r\nawait dbContext.Entry(book)\r\n    .Reference(b => b.Details)\r\n    .LoadAsync(cancellationToken);\r\n    \r\nawait dbContext.Entry(book)\r\n    .Collection(b => b.Categories)\r\n    .LoadAsync(cancellationToken);\r\n```\r\n\r\n**What's happening:**\r\n- We first load just the book entity\r\n- Then we manually load specific related data when needed\r\n- `.Reference()` is used for single-entity relationships (like Author)\r\n- `.Collection()` is used for collection relationships (like Categories)\r\n\r\n**When to use it:**\r\n- When you need fine-grained control over what gets loaded and when\r\n- When you need to conditionally load related data\r\n- When working with large entities where you only sometimes need related data\r\n\r\n**Pros:** Complete control over what gets loaded and when\r\n**Cons:** Requires multiple database trips, more code to write",
      "line": 66
    },
    {
      "file": "EFCore101.API/Endpoints/LoadingExamplesEndpoints.cs",
      "description": "# Projection with Select\r\n\r\n```csharp\r\nvar bookDtos = await context.Books\r\n    .AsNoTracking()\r\n    .Select(b => new BookSummaryDto\r\n    {\r\n        Id = b.Id,\r\n        Title = b.Title,\r\n        AuthorName = b.Author != null ? b.Author.Name : \"Unknown\",\r\n        PublisherName = b.Publisher != null ? b.Publisher.Name : \"Unknown\",\r\n        PageCount = b.Details != null ? b.Details.NumberOfPages : 0,\r\n        Categories = b.Categories.Select(c => c.Name).ToList()\r\n    })\r\n    .ToListAsync(cancellationToken);\r\n```\r\n\r\n**What's happening:**\r\n- We use `.Select()` to pick only the specific properties we need\r\n- We map directly to a DTO (Data Transfer Object) rather than loading full entities\r\n- EF Core optimizes the SQL query to only retrieve the columns we actually need\r\n\r\n**When to use it:**\r\n- When you need only specific fields, not entire entities\r\n- For API responses where you need a specific data shape\r\n- For the best read performance\r\n\r\n**Pros:** Most efficient for read operations, minimal memory usage\r\n**Cons:** Cannot modify and save the entities (read-only)\r\n\r\n## How Lazy Loading is Configured\r\n\r\nIn our Program.cs file:\r\n\r\n```csharp\r\nbuilder.AddNpgsqlDbContext<EFCore101DbContext>(\r\n    connectionName: \"postgresdb\", \r\n    configureDbContextOptions: options => options.UseLazyLoadingProxies());\r\n```\r\n\r\nThis tells Entity Framework Core to:\r\n1. Create a DbContext using the PostgreSQL provider\r\n2. Enable lazy loading using the proxies approach\r\n3. Use the connection string named \"postgresdb\" from configuration\r\n\r\nRemember that for lazy loading to work, your navigation properties must be marked as `virtual`.",
      "line": 101
    },
    {
      "file": "EFCore101.API/Endpoints/ClientServerEvaluationEndpoints.cs",
      "description": "# Understanding Client vs Server Evaluation in Entity Framework Core\r\n\r\nIn Entity Framework Core, queries can be executed in two places:\r\n- **Server Evaluation:** Query runs entirely on the database server (SQL)\r\n- **Client Evaluation:** Query runs partially or fully in your application's memory (C#)",
      "line": 10
    },
    {
      "file": "EFCore101.API/Endpoints/ClientServerEvaluationEndpoints.cs",
      "description": "## Server Evaluation (Preferred)\r\n\r\nServer evaluation translates your LINQ query into SQL and executes it entirely on the database server.\r\n\r\n```csharp\r\n// Server Evaluation Example - Runs entirely as SQL\r\nvar books = await context.Books\r\n    .Where(b => b.Title.Contains(\"Entity Framework\"))\r\n    .OrderBy(b => b.Title)\r\n    .ToListAsync();\r\n```\r\n\r\n**Benefits:**\r\n- Efficient database queries\r\n- Uses database indexes\r\n- Minimizes data transfer\r\n- Handles large datasets well",
      "line": 17
    },
    {
      "file": "EFCore101.API/Endpoints/ClientServerEvaluationEndpoints.cs",
      "description": "## Client Evaluation (Use Cautiously)\r\n\r\nClient evaluation happens when EF Core can't translate parts of your query to SQL.\r\n\r\n```csharp\r\n// Client Evaluation Example - Loads ALL books then filters in memory\r\nvar books = await context.Books.ToListAsync();\r\nvar filteredBooks = books\r\n    .Where(b => b.Title.IndexOf(\"entity\", StringComparison.OrdinalIgnoreCase) >= 0)\r\n    .OrderBy(b => b.Title)\r\n    .ToList();\r\n```\r\n\r\n**Drawbacks:**\r\n- Loads unnecessary data\r\n- Poor performance on large datasets\r\n- Bypasses database indexes\r\n- Higher memory usage",
      "line": 36
    },
    {
      "file": "EFCore101.API/Endpoints/ClientServerEvaluationEndpoints.cs",
      "description": "## EF.Functions for Better SQL Translation\r\n\r\nEF.Functions provides database-specific functions that translate well to SQL.\r\n\r\n```csharp\r\n// EF.Functions Example - Optimized SQL translation\r\nvar books = await context.Books\r\n    .Where(b => EF.Functions.Like(b.Title, \"%Entity%\"))\r\n    .Where(b => EF.Functions.Like(b.Description, \"%Framework%\"))\r\n    .OrderBy(b => b.Title)\r\n    .ToListAsync();\r\n```\r\n\r\n**When to use:**\r\n- For database-specific operations (LIKE, DateDiff, etc.)\r\n- To ensure server evaluation of complex predicates\r\n- To optimize performance-critical queries",
      "line": 115
    },
    {
      "file": "EFCore101.API/Endpoints/QueryableEnumerableEndpoints.cs",
      "description": "# Cartesian Explosion in Entity Framework Core\r\n\r\nRead more: https://code-maze.com/efcore-single-and-split-queries/\r\n\r\nA cartesian explosion (also called a cartesian product problem) occurs in database queries when you join multiple tables together, especially when including many related entities with Entity Framework Core's `.Include()` method.\r\n\r\n## What Happens During a Cartesian Explosion\r\n\r\nWhen you include multiple related entities in a single query, EF Core typically generates SQL with multiple JOINs. This can cause the result set to grow exponentially because:\r\n\r\n1. Each row from the first table is combined with every matching row from the second table\r\n2. Those combined rows are then matched with every relevant row from the third table\r\n3. And so on for each additional relationship\r\n\r\n## Example\r\n\r\n```csharp\r\n// This query could cause a cartesian explosion\r\nvar books = await context.Books\r\n    .Include(b => b.Author)         // One-to-one relationship\r\n    .Include(b => b.Publisher)      // One-to-one relationship\r\n    .Include(b => b.Categories)     // One-to-many relationship (potentially many categories)\r\n    .Include(b => b.Reviews)        // One-to-many relationship (potentially many reviews)\r\n    .ToListAsync();\r\n```\r\n\r\nIf a book has 5 categories and 10 reviews, the database might return 50 duplicate book rows that EF Core must then deduplicate in memory.\r\n\r\n## Problems Caused\r\n\r\n- **Excessive memory usage**: The database returns much more data than needed\r\n- **Poor performance**: Processing large result sets takes time\r\n- **Network bottlenecks**: Transferring redundant data wastes bandwidth\r\n- **Timeouts**: Queries may time out with large datasets\r\n\r\n## Solution: Split Queries\r\n\r\nEF Core's split query feature solves this by executing separate SQL queries for each relationship:\r\n\r\n```csharp\r\nvar books = await context.Books\r\n    .Include(b => b.Author)\r\n    .Include(b => b.Publisher)\r\n    .Include(b => b.Categories)\r\n    .Include(b => b.Reviews)\r\n    .AsSplitQuery()  // This prevents cartesian explosion\r\n    .ToListAsync();\r\n```",
      "line": 187
    },
    {
      "file": "EFCore101.API/Endpoints/QueryableEnumerableEndpoints.cs",
      "description": "# IQueryable Example (Deferred Execution)\r\n\r\n```csharp\r\n// IQueryable represents a query that hasn't been executed yet\r\nIQueryable<Book> booksQuery = context.Books;\r\n\r\n// Each of these operations modifies the query but doesn't execute it\r\nbooksQuery = booksQuery.Where(b => b.Title.Contains(\"Entity\"));\r\nbooksQuery = booksQuery.OrderBy(b => b.Title);\r\n\r\n// Query is only executed when we call ToListAsync()\r\nvar books = await booksQuery.ToListAsync(cancellationToken);\r\n```\r\n\r\nThis example shows how `IQueryable<T>` allows you to build up a query in stages without executing it. The database query only runs when you call a materialization method like `ToListAsync()`. This generates a single optimized SQL query.\r\n",
      "line": 17
    },
    {
      "file": "EFCore101.API/Endpoints/QueryableEnumerableEndpoints.cs",
      "description": "# IEnumerable Example (Immediate Execution)\r\n\r\n```csharp\r\n// This executes the query immediately, returning all books from database\r\nIEnumerable<Book> booksEnumerable = await context.Books.ToListAsync(cancellationToken);\r\n\r\n// These operations happen in memory, not in the database\r\nbooksEnumerable = booksEnumerable.Where(b => b.Title.Contains(\"Entity\"));\r\nbooksEnumerable = booksEnumerable.OrderBy(b => b.Title);\r\n```\r\n\r\nThis demonstrates how `IEnumerable<T>` works with data already loaded into memory. The initial `ToListAsync()` executes the query immediately, bringing all books into memory. Subsequent filtering and sorting happen in application memory, not in the database.\r\n\r\n## 3. Performance Comparison\r\n\r\n```csharp\r\n// IQueryable approach - single database query\r\nvar booksQueryable = await context.Books\r\n    .Where(b => b.Title.Contains(\"Entity\"))\r\n    .OrderBy(b => b.Title)\r\n    .Take(10)\r\n    .ToListAsync(cancellationToken);\r\n\r\n// IEnumerable approach - loads all data first\r\nvar allBooks = await context.Books.ToListAsync(cancellationToken);\r\nvar booksEnumerable = allBooks\r\n    .Where(b => b.Title.Contains(\"Entity\"))\r\n    .OrderBy(b => b.Title)\r\n    .Take(10)\r\n    .ToList();\r\n```\r\n\r\nThis endpoint compares the performance of both approaches, measuring execution time. The `IQueryable` version is typically more efficient because it filters, sorts, and limits results at the database level before transferring data.\r\n",
      "line": 49
    },
    {
      "file": "EFCore101.API/Endpoints/QueryableEnumerableEndpoints.cs",
      "description": "# Split Queries Example\r\n\r\n```csharp\r\n// Single query approach (may cause cartesian explosion)\r\nvar booksWithSingleQuery = await context.Books\r\n    .Include(b => b.Author)\r\n    .Include(b => b.Publisher)\r\n    .Include(b => b.Details)\r\n    .Include(b => b.Categories)\r\n    .ToListAsync(cancellationToken);\r\n\r\n// Split query approach\r\nvar booksWithSplitQueries = await context.Books\r\n    .Include(b => b.Author)\r\n    .Include(b => b.Publisher)\r\n    .Include(b => b.Details)\r\n    .Include(b => b.Categories)\r\n    .AsSplitQuery() // This is the key difference\r\n    .ToListAsync(cancellationToken);\r\n```\r\n\r\nThis demonstrates how split queries can solve the cartesian explosion problem. The first query generates a single SQL statement with multiple JOINs, potentially returning duplicate data. The second query uses `AsSplitQuery()` to generate separate SQL queries for each included relationship.\r\n",
      "line": 121
    }
  ]
}