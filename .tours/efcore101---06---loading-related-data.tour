{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "EFCore101 - 06 - Loading related data",
  "steps": [
    {
      "file": "EFCore101.API/Endpoints/LoadingExamplesEndpoints.cs",
      "description": "# Eager Loading\r\n\r\n```csharp\r\nvar booksWithAuthorsAndPublishers = await context.Books\r\n    .AsNoTracking()\r\n    .Include(b => b.Author)\r\n    .Include(b => b.Publisher)\r\n    .Include(b => b.Details)\r\n    .Include(b => b.Categories)\r\n    .ToListAsync(cancellationToken);\r\n```\r\n\r\n**What's happening:**\r\n- We load books AND all their related data (authors, publishers, details, categories) in a **single database query**\r\n- The `.Include()` method tells EF Core which related entities to bring along\r\n- `.AsNoTracking()` improves performance when we only need to read data, not modify it\r\n\r\n**When to use it:**\r\n- When you know you'll need the related data\r\n- When you want to avoid multiple database trips\r\n- For displaying complete information about entities and their relationships\r\n\r\n**Pros:** One database trip, prevents the \"N+1 query problem\" (where you make 1 query for main data + N queries for each related item)\r\n**Cons:** May retrieve more data than you actually need",
      "line": 15
    },
    {
      "file": "EFCore101.API/Endpoints/LoadingExamplesEndpoints.cs",
      "description": "# Lazy Loading\r\n\r\n```csharp\r\nvar books = await context.Books.ToListAsync(cancellationToken);\r\n\r\nvar result = books.Select(book => new\r\n{\r\n    BookId = book.Id,\r\n    Title = book.Title,\r\n    // These will trigger separate database queries when accessed\r\n    AuthorName = book.Author?.Name,\r\n    PublisherName = book.Publisher?.Name,\r\n    CategoryCount = book.Categories.Count,\r\n    PageCount = book.Details?.NumberOfPages\r\n}).ToList();\r\n```\r\n\r\n**What's happening:**\r\n- We first load just the books (without related data)\r\n- When we access navigation properties like `book.Author` or `book.Categories`, EF Core automatically makes additional database queries to load that data\r\n- This requires:\r\n  1. Virtual navigation properties (`public virtual Author? Author { get; set; }`)\r\n  2. The Microsoft.EntityFrameworkCore.Proxies package\r\n  3. Enabling lazy loading in your DbContext configuration\r\n\r\n**When to use it:**\r\n- When you're not sure which related data you'll need\r\n- For simple applications where performance isn't critical\r\n- When working with a small number of entities\r\n\r\n**Pros:** Simple to use, loads only what you actually access\r\n**Cons:** Can cause performance problems (the N+1 query problem) when working with many entities",
      "line": 36
    },
    {
      "file": "EFCore101.API/Endpoints/LoadingExamplesEndpoints.cs",
      "description": "# Explicit Loading\r\n\r\n```csharp\r\nvar book = await dbContext.Books\r\n    .SingleOrDefaultAsync(b => b.Id == bookId, cancellationToken);\r\n    \r\n// Then explicitly load related data as needed\r\nawait dbContext.Entry(book)\r\n    .Reference(b => b.Author)\r\n    .LoadAsync(cancellationToken);\r\n    \r\nawait dbContext.Entry(book)\r\n    .Reference(b => b.Details)\r\n    .LoadAsync(cancellationToken);\r\n    \r\nawait dbContext.Entry(book)\r\n    .Collection(b => b.Categories)\r\n    .LoadAsync(cancellationToken);\r\n```\r\n\r\n**What's happening:**\r\n- We first load just the book entity\r\n- Then we manually load specific related data when needed\r\n- `.Reference()` is used for single-entity relationships (like Author)\r\n- `.Collection()` is used for collection relationships (like Categories)\r\n\r\n**When to use it:**\r\n- When you need fine-grained control over what gets loaded and when\r\n- When you need to conditionally load related data\r\n- When working with large entities where you only sometimes need related data\r\n\r\n**Pros:** Complete control over what gets loaded and when\r\n**Cons:** Requires multiple database trips, more code to write",
      "line": 66
    },
    {
      "file": "EFCore101.API/Endpoints/LoadingExamplesEndpoints.cs",
      "description": "# Projection with Select\r\n\r\n```csharp\r\nvar bookDtos = await context.Books\r\n    .AsNoTracking()\r\n    .Select(b => new BookSummaryDto\r\n    {\r\n        Id = b.Id,\r\n        Title = b.Title,\r\n        AuthorName = b.Author != null ? b.Author.Name : \"Unknown\",\r\n        PublisherName = b.Publisher != null ? b.Publisher.Name : \"Unknown\",\r\n        PageCount = b.Details != null ? b.Details.NumberOfPages : 0,\r\n        Categories = b.Categories.Select(c => c.Name).ToList()\r\n    })\r\n    .ToListAsync(cancellationToken);\r\n```\r\n\r\n**What's happening:**\r\n- We use `.Select()` to pick only the specific properties we need\r\n- We map directly to a DTO (Data Transfer Object) rather than loading full entities\r\n- EF Core optimizes the SQL query to only retrieve the columns we actually need\r\n\r\n**When to use it:**\r\n- When you need only specific fields, not entire entities\r\n- For API responses where you need a specific data shape\r\n- For the best read performance\r\n\r\n**Pros:** Most efficient for read operations, minimal memory usage\r\n**Cons:** Cannot modify and save the entities (read-only)\r\n\r\n## How Lazy Loading is Configured\r\n\r\nIn our Program.cs file:\r\n\r\n```csharp\r\nbuilder.AddNpgsqlDbContext<EFCore101DbContext>(\r\n    connectionName: \"postgresdb\", \r\n    configureDbContextOptions: options => options.UseLazyLoadingProxies());\r\n```\r\n\r\nThis tells Entity Framework Core to:\r\n1. Create a DbContext using the PostgreSQL provider\r\n2. Enable lazy loading using the proxies approach\r\n3. Use the connection string named \"postgresdb\" from configuration\r\n\r\nRemember that for lazy loading to work, your navigation properties must be marked as `virtual`.",
      "line": 101
    }
  ]
}