{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "EFCore101 - 04 - Improving our dbcontext",
  "steps": [
    {
      "file": "EFCore101.API/context/EFCore101DbContext.cs",
      "description": "# Automatic Audit Trail Management in Entity Framework Core\r\n\r\nThis code is part of the database saving process and automatically manages audit fields for all entities. The `ChangeTracker` keeps track of all entities that have been modified during a database operation.\r\n\r\n```csharp\r\n// Apply audit information before saving changes\r\n  var addedEntries = ChangeTracker.Entries<IAuditableEntity>().Where(e => e.State == EntityState.Added);\r\n\r\n        var modifiedEntries = ChangeTracker.Entries<IAuditableEntity>().Where(e => e.State == EntityState.Modified);\r\n\r\n        var deletedEntries = ChangeTracker.Entries<ISoftDeleteEntity>().Where(e => e.State == EntityState.Deleted);\r\n\r\n        foreach (var entry in addedEntries)\r\n        {\r\n            HandleCreateAuditFields(entry);\r\n        }\r\n\r\n        foreach (var entry in modifiedEntries)\r\n        {\r\n            HandleUpdateAuditFields(entry);\r\n        }\r\n\r\n        foreach (var entry in deletedEntries)\r\n        {\r\n            HandleDeleteAuditFields(entry);\r\n        }\r\n```\r\n\r\nHere, we're looping through each entity in the tracker that inherits from `BaseEntity<Guid>` and applying two helper methods:\r\n- One that handles setting creation timestamps for new records\r\n- Another that updates the \"last modified\" timestamp for changed records\r\n\r\nThis is a powerful feature that ensures your audit fields (`CreatedAt` and `UpdatedAt`) are always correctly maintained without having to manually set them in every place you create or update entities.\r\n\r\nIt's like having an automatic record-keeper that timestamps all your data changes consistently throughout your application.",
      "line": 38
    },
    {
      "file": "EFCore101.API/context/EFCore101DbContext.cs",
      "description": "# Global Query Filters in Entity Framework Core\r\n\r\nGlobal query filters in Entity Framework Core automatically apply predefined conditions to all queries for specific entity types. The line `modelBuilder.Entity<BaseEntity<Guid>>().HasQueryFilter(e => !e.IsDeleted)` creates a filter that excludes any entity marked as deleted (where `IsDeleted = true`) from all queries.\r\n\r\nThis means when you write `context.Books.ToList()`, you'll only get non-deleted books without explicitly adding a where clause. The filter applies across your entire application, ensuring consistency.\r\n\r\n## Other Common Examples Include:\r\n\r\n- **Multi-tenancy**: \r\n  ```csharp\r\n  modelBuilder.Entity<TenantEntity>().HasQueryFilter(e => e.TenantId == currentTenantId)\r\n  ```\r\n\r\n- **User-specific data**: \r\n  ```csharp\r\n  modelBuilder.Entity<UserData>().HasQueryFilter(e => e.UserId == currentUserId)\r\n  ```\r\n\r\n- **Active records**: \r\n  ```csharp\r\n  modelBuilder.Entity<Subscription>().HasQueryFilter(e => e.ExpiryDate > DateTime.UtcNow)\r\n  ```\r\n\r\nThese filters can be temporarily bypassed when needed using `.IgnoreQueryFilters()` in specific queries.",
      "line": 23
    },
    {
      "file": "EFCore101.API/Entities/Base/BaseEntity.cs",
      "description": "# Soft Delete in Entity Framework Core\r\n\r\nThe `public bool IsDeleted { get; set; }` property implements \"soft delete\" functionality in your entity. Rather than permanently removing records from the database when deleted, this flag marks them as \"deleted\" while keeping the data intact.\r\n\r\n```csharp\r\npublic class BaseEntity<T>\r\n{\r\n    public T Id { get; set; }\r\n    public DateTime CreatedAt { get; set; }\r\n    public DateTime UpdatedAt { get; set; }\r\n    public bool IsDeleted { get; set; }\r\n}\r\n```\r\n\r\nWhen set to `true`, the application treats the record as if it doesn't exist in normal queries, but the data remains in the database for:\r\n- Historical purposes\r\n- Audit trails\r\n- Potential recovery\r\n\r\n## Benefits of Soft Delete\r\n\r\nThis approach is valuable for:\r\n- Maintaining data integrity\r\n- Supporting data recovery\r\n- Tracking deletion history\r\n- Preserving referential relationships\r\n\r\nIt's commonly used in business applications where completely removing data could cause problems with referential integrity or compliance requirements.",
      "line": 6
    }
  ]
}