{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "EFCore101 - 03 - Writing our first query",
  "steps": [
    {
      "file": "EFCore101.API/Context/IEFCore101DbContext.cs",
      "description": "# Benefits of Using DbContext Interfaces\r\n\r\n## Why Create an Interface for Your DbContext?\r\n\r\nCreating an interface for your DbContext (like `IEFCore101DbContext`) provides several important benefits:\r\n\r\n### Dependency Inversion\r\n- Follows the Dependency Inversion Principle\r\n- Allows higher-level modules to depend on abstractions rather than concrete implementations\r\n- Promotes loose coupling between components\r\n\r\n### Enhanced Testability\r\n- Makes unit testing significantly easier\r\n- Enables mocking the database context in tests\r\n- Avoids hitting the actual database during test execution\r\n\r\n### Implementation Flexibility\r\n- Swap implementations without changing consumer code\r\n- Easily use in-memory database for testing\r\n- Support different database providers when needed\r\n\r\n### Clear Contract Definition\r\n- Clearly defines available operations for consumers\r\n- Creates a more explicit API contract\r\n- Improves code discoverability and documentation\r\n\r\n### Separation of Concerns\r\n- Separates data access interface from implementation\r\n- Makes the codebase more maintainable\r\n- Follows single responsibility principle",
      "line": 3
    },
    {
      "file": "EFCore101.API/Program.cs",
      "description": "# Registering DbContext with Dependency Injection\r\n\r\nThis code registers the database context with the ASP.NET Core dependency injection container using a scoped lifetime. It maps the `IEFCore101DbContext` interface to its concrete implementation `EFCore101DbContext`.\r\n\r\n```csharp\r\n// Register DbContext with dependency injection\r\nbuilder.Services.AddDbContext<EFCore101DbContext>(options =>\r\n    options.UseNpgsql(builder.Configuration.GetConnectionString(\"DefaultConnection\")));\r\n\r\n// Register the interface with its implementation\r\nbuilder.Services.AddScoped<IEFCore101DbContext, EFCore101DbContext>();\r\n```\r\n\r\nThe scoped lifetime ensures that:\r\n- A new instance is created for each HTTP request\r\n- The same instance is used throughout the request's lifetime\r\n- Resources are properly disposed after the request completes",
      "line": 17
    },
    {
      "file": "EFCore101.API/Endpoints/BookEndpoints.cs",
      "description": "# Creating a Book Resource with ASP.NET Core Minimal API\r\n\r\nThis code defines an HTTP POST endpoint at \"/books\" using ASP.NET Core's minimal API syntax. When a client sends a POST request to this URL, the following happens:\r\n\r\n1. The endpoint receives a `BookRequest` object from the request body and automatically injects the database context (`IEFCore101DbContext`) and a cancellation token.\r\n\r\n2. It creates a new `Book` entity, mapping properties from the request and setting the creation/update timestamps to the current UTC time.\r\n\r\n3. The book is added to the database context asynchronously using `AddAsync()`, which stages it for insertion.\r\n\r\n4. `SaveChangesAsync()` commits the changes to the database, generating an ID for the new book.\r\n\r\n5. Finally, it returns a 201 Created response with the URL to access the new resource and the created book object in the response body.\r\n\r\n```csharp\r\ngroup.MapPost(\"/\", async (IEFCore101DbContext context, BookRequest request, CancellationToken cancellationToken) =>\r\n{\r\n    var book = new Book\r\n    {\r\n        Title = request.Title,\r\n        Description = request.Description,\r\n        ImageUrl = request.ImageUrl,\r\n        AuthorId = request.AuthorId,\r\n        PublisherId = request.PublisherId,\r\n        CreatedAt = DateTime.UtcNow,\r\n        UpdatedAt = DateTime.UtcNow\r\n    };\r\n\r\n    await context.Books.AddAsync(book, cancellationToken);\r\n    await context.SaveChangesAsync(cancellationToken);\r\n\r\n    return Results.Created($\"/books/{book.Id}\", book);\r\n});\r\n```",
      "line": 11
    }
  ]
}